//Подключение стандартной библиотеки для ввода и вывод информации
#include <stdio.h>
//Подключение стандартной библиотеки для работы с математическими операциями
#include <math.h>
//Прототипы функциий для приближенного нахождения корня уравнений, принимают 3 аргумента 
float func2(float,float,float);
float func3(float,float,float);
float func4(float,float,float); 
float myfunc1(float,float,float); 
float myfunc2(float,float,float); 
float myfunc3(float,float,float); 
//Массив указателей на функцию, функции принимают 3 аргумента
float (*func[6])(float,float,float) = {func2,func3,func4,myfunc1,myfunc2,myfunc3};
//Прототип функции метода половинного деления, принимает 4 аргумента
void halvmethod(float,float,int,float);
//Прототип функции метода секущих, принимает 4 аргумента
void secantmethod(float,float,int,float);
//Массив указателей на функцию, функции принимают 4 аргумента
void (*methods[2])(float,float,int,float) = {halvmethod,secantmethod};

//Вход в программу
int main()
{
	//Объявление целочисленных переменных:mkey - значение для выбора метода,fkey-значение для выбора функции
	int mkey,fkey;
	//Объявление переменных вещественного типа: e - точность, c и d - параметры в функциях
	float e,c,d;
	//Вывод на экран запроса о введении параметров c и d
	printf("Введите параметры c и d\n");
	//Ввод значений c и d
		scanf("%f%f",&c,&d);
	//Вход в цикл с постусловием
	do{
	//Вывод на экран запроса о введении точности
	printf("Введите значение e\n");
	//Ввод точности
	scanf("%f",&e);
	//Если точность не больше нуля, то вывод предупреждения
	if(e<=0) printf("Точность должна быть больше нуля\n");
	//Выполняется,пока точность <= 0
	}while(e<=0);
	//Вывод на экран запроса о выборе функции
	printf("Введите номер функции\n 0 - e^(c*x)-d\n 1 - log2(c*x)-d\n 2 - x^3+c * x^2 + d\n 3 - c*x+d*exp(x)\n 4 - log2(c*x)+log(d*x)\n 5 - log2(x^3*c)+e^(d*x^2)\n");
	//Ввод значения для выбора функции
		scanf("%d",&fkey);
	//Выбор на экран запроса о выборе метода
	printf("Введите номер метода\n 0 - метод деления пополам\n 1 - метод секущих\n");
	//Ввод значения для выбора метода
		scanf("%d",&mkey);
	//Вызов выбранного метода с функцией
	methods[mkey](c,d,fkey,e); 
}
//Заголовок метода половинного деления
void halvmethod(float c,float d,int fkey,float eps) 
{
	//Переменные вещественного типа: g - точка сдвига,a и b - концы отрезка
	float g,a,b;
	//Целочисленная переменная для подсчёта кол-ва итераций
	int n=0;
	//Вывод запроса о введении значений отрезка
	printf("Введите значения отрезка a и b\n");
	//Вход в цикл с постусловием
	do{
		//Ввод значений отрезка
		scanf("%f%f",&a,&b);
		//Если a>=b
		if(a>=b)
		//То вывод предупреждения
			printf("Значение a должно быть меньше значения b\n");
		//Иначе если функции имеют один и тот же знак
		else if((func[fkey](b,c,d)>0&&func[fkey](a,c,d)>0)||(func[fkey](b,c,d)<0&&func[fkey](a,c,d)<0))
		//То вывод предупреждения
			printf("Функции имеют один и тот же знак\n");
	//Выполняется пока a>=b или функции имеют один и тот же знак
	}while((a>=b)||(func[fkey](b,c,d)>0&&func[fkey](a,c,d)>0)||(func[fkey](b,c,d)<0&&func[fkey](a,c,d)<0));
	//Вход в цикл с предусловием, выполняется пока длина отрезка больше точности
	while(fabs(b-a)>eps)
	{
		//Присвоение переменной точку сдвига
		g=(a+b)/2;
		//Если выбранное уравнение в точке сдвига <0 , то сдвиг левой границы отрезка
		if(func[fkey](g,c,d)<0) a = g;
		//Иначе сдвиг правой границы
		else if (func[fkey](g,c,d)>0) b = g;
		//Инкрементация кол-ва итераций
		n++;
		//Если количество итераций = 500
		if(n==500) 
		{
		//То, вывод ошибки
			printf("Ошибка!Возможно введено слишком малое значение e");
		//И завершение работы функции
			return;
		}	
	}
	//Вывод на экран итогового значения и кол-ва итераций
	printf("Итоговое значение = %f,\nКоличество итераций = %d\n",g,n);
}
//Заголовок метода секущих
void secantmethod(float c,float d,int fkey, float eps) 
{
	//Переменные вещественного типа: x - для сохранения предыдущего приближения, x1 и x2 - начальные приближения
	float x,xn1=1.5,xn2=0.5;
	//Целочисленная переменная для подсчёта кол-ва итераций
	int n =0;
	
	//Вход в цикл с постусловием
	do{
		//Вычисление нового приближения
		x = xn2 - func[fkey](xn2, c, d)*(xn2-xn1)/(func[fkey](xn2, c, d) - func[fkey](xn1, c, d));
		//Изменяем приближения
		xn1 = xn2;
		xn2 = x;
		//Инкрементация кол-ва итераций
		n++;
		//Если кол-во итераций = 500
		if(n==5000) 
		{
			//То, вывод ошибки
			printf("Ошибка");
			//Завершение работы функции
			return;
		}	
		//Цикл проверки правильности найденного приближения
		while ((fabs(xn1 - xn2) <= eps) && (func[fkey](xn2 + eps, c, d) * func[fkey](xn2 - eps, c, d) > 0) && (eps != 0)) 
		//Уменьшение погрешности
		eps /= 10;
	//Выполняется, пока не достигнется нужная точность
	}while(fabs(func[fkey](xn1, c, d)-func[fkey](x, c, d)) > eps);
	//Вывод на экран итогового значения и кол-ва итераций
	printf("Итоговое значение = %f\n Количество итераций = %d",xn2,n);
}
//Заголовок функции №2 в методических указаниях
float func2(float x,float c,float d)
{
//Возвращает значение уравнения
	return exp(c*x)- d;
}
//Заголовок функции №3 в методических указаниях
float func3(float x,float c,float d)
{
//Возвращает значение уравнения
	return log2(c*x)-d;
}
//Заголовок функции №4 в методических указаниях
float func4(float x,float c,float d)
{
//Возвращает значение уравнения
	return pow(x,3)+c*pow(x,2)+d;
}
//Заголовок придуманной функции №1
float myfunc1(float x,float c,float d)
{
//Возвращает значение уравнения
	return c*x+d*exp(x);
}
//Заголовок придуманной функции №2
float myfunc2(float x,float c,float d)
{
//Возвращает значение уравнения
	return log2(c*x)+log(d*x);
}

//Заголовок придуманной функции №3
float myfunc3(float x,float c,float d)
{
//Возвращает значение уравнения
	return log(c*x)+pow(x*d,2);
}

